#define DetTCuts_Coin_cxx

#include "DetTCuts_Coin.h"
#include <TH1.h>
#include <TH2.h>
#include <TF1.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TPaveText.h>
#include <TSpectrum.h>
#include <TList.h>
#include <TPolyMarker.h>
#include <TGraphErrors.h>
#include <TMath.h>
#include <iostream>
#include <iomanip>
#include <fstream>
#include "TProof.h"

using namespace TMath;

void DetTCuts_Coin::Begin(TTree * /*tree*/)
{
  printf("\n\n");
  TString option = GetOption();
}

void DetTCuts_Coin::SlaveBegin(TTree * /*tree*/)
{
  printf("\n\n");
  TString option = GetOption();

  //HMS Histos
  for (Int_t ipmt = 0; ipmt < 2; ipmt++){
    h1hCerAdcTdcTDiff[ipmt] = new TH1F (Form("hCER%d_timeDiff", ipmt+1), Form("HMS Cer PMT%d AdcTdcTimeDiff", ipmt+1), 200, 0, 200);
    GetOutputList()->Add(h1hCerAdcTdcTDiff[ipmt]);
  }
  for (Int_t i = 0; i < 12; i++){
    h1hdcTdcT[i] = new TH1F( Form("hDC%s_rawTDC", dc_pl_names[i].c_str()), Form("HMS DC Plane %s Raw TDC", dc_pl_names[i].c_str()), 200, -20000, 0);
    GetOutputList()->Add(h1hdcTdcT[i]);
  }
  for (Int_t npl = 0; npl < cal_planes; npl++){ // Loop over all calorimeter planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      if(npl == 2 && nside == 1) continue; // Skip 3ta/4ta- since they don't exist!
      if(npl == 3 && nside == 1) continue;
      for (Int_t ipmt = 0; ipmt < 13; ipmt++){ // Loop over each PMT in a particular plane	
	h1hCalAdcTdcTDiff[npl][nside][ipmt] = new TH1F(Form("hCal%s%d%s_timeDiff", cal_pl_names[npl].c_str(), ipmt+1, nsign[nside].c_str()), Form("HMS Cal %s%d%s AdcTdcTimeDiff", cal_pl_names[npl].c_str(), ipmt+1, nsign[nside].c_str()), 200, -100, 100);
	GetOutputList()->Add(h1hCalAdcTdcTDiff[npl][nside][ipmt]);
      }
    }
  }
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      for (Int_t ipmt = 0; ipmt < hmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	h1hHodoAdcTdcTDiff[npl][nside][ipmt] = new TH1F(Form("hHodo%s%d%s_timeDiff", hod_pl_names[npl].c_str(),ipmt+1,nsign[nside].c_str() ), Form("HMS Hodo %s%d%s AdcTdcTimeDiff", hod_pl_names[npl].c_str(), ipmt+1, nsign[nside].c_str()), 200, -100, 100);
	GetOutputList()->Add(h1hHodoAdcTdcTDiff[npl][nside][ipmt]);
      }
    }
  }
  
  // SHMS Histos
  for (Int_t ipmt = 0; ipmt < 4; ipmt++){
    h1pHGCAdcTdcTDiff[ipmt] = new TH1F (Form("pHGCER%d_timeDiff", ipmt+1), Form("SHMS HGCer PMT%d AdcTdcTimeDiff", ipmt+1), 200, 0, 100);
    GetOutputList()->Add(h1pHGCAdcTdcTDiff[ipmt]);
  }
  for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
    for (Int_t ipmt = 0; ipmt < 7; ipmt++){ // Loop over PMTs
      h1pAeroAdcTdcTDiff[nside][ipmt] = new TH1F(Form("pAero%d%s_timeDiff", ipmt+1, nsign[nside].c_str()), Form("SHMS Aerogel PMT%d%s AdcTdcTimeDiff", ipmt+1, nsign[nside].c_str()), 200, 0, 400);
      GetOutputList()->Add(h1pAeroAdcTdcTDiff[nside][ipmt]);
    }
  }
  for (Int_t i = 0; i < 12; i++){
    h1pdcTdcT[i] = new TH1F( Form("pDC%s_rawTDC", dc_pl_names[i].c_str()), Form("SHMS DC Plane %s Raw TDC", dc_pl_names[i].c_str()), 200, -20000, 0);
    GetOutputList()->Add(h1pdcTdcT[i]);
  }
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      for (Int_t ipmt = 0; ipmt < pmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	h1pHodoAdcTdcTDiff[npl][nside][ipmt] = new TH1F(Form("pHodo%s%d%s_timeDiff", hod_pl_names[npl].c_str(),ipmt+1,nsign[nside].c_str() ), Form("SHMS Hodo %s%d%s AdcTdcTimeDiff", hod_pl_names[npl].c_str(), ipmt+1,nsign[nside].c_str()), 200, -100, 100);
	GetOutputList()->Add(h1pHodoAdcTdcTDiff[npl][nside][ipmt]);
      }
    }
  }
  for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
    for (Int_t ipmt = 0; ipmt < 14; ipmt++){ // Loop over PMTs
      h1pPrShAdcTdcTDiff[nside][ipmt] = new TH1F(Form("pPrSh%d%s_timeDiff", ipmt+1, nsign[nside].c_str()), Form("SHMS Pre-Shower PMT%d%s AdcTdcTimeDiff", ipmt+1, nsign[nside].c_str()), 200, -200, 200);
      GetOutputList()->Add(h1pPrShAdcTdcTDiff[nside][ipmt]);
    }
  }
  for(Int_t ipmt = 0; ipmt < 224; ipmt++){
    h1pCalAdcTdcTDiff[ipmt] = new TH1F(Form("pCalPMT%d", ipmt+1), Form("SHMS Calorimeter PMT%d AdcTdcTimeDiff", ipmt+1), 200, -100, 100); 
    GetOutputList()->Add(h1pCalAdcTdcTDiff[ipmt]);
  }

}

Bool_t DetTCuts_Coin::Process(Long64_t entry)
{
  fReader.SetEntry(entry);
  
  // Fill our HMS timing histograms, explicitly select only multiplicity 1 events
  for (Int_t ipmt = 0; ipmt < 2; ipmt++){
    if(H_cer_goodAdcMult[ipmt] == 1) h1hCerAdcTdcTDiff[ipmt]->Fill(H_cer_goodAdcTdcDiffTime[ipmt]);
  }
  // This is a disgustingly bad way of doing this, really need to figure out how to have some ARRAY of readers
  for (Int_t i = 0; i < 12; i++){
    if(i == 0){
      if(H_dc_1u1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1u1_rawtdc[0]);
    }
    else if(i == 1){
      if(H_dc_1u2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1u2_rawtdc[0]);
    }
    else if(i == 2){
      if(H_dc_1x1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1x1_rawtdc[0]);
    }
    else if(i == 3){
      if(H_dc_1x2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1x2_rawtdc[0]);
    }
    else if(i == 4){
      if(H_dc_1v1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1v1_rawtdc[0]);
    }
    else if(i == 5){
      if(H_dc_1v2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_1v2_rawtdc[0]);
    }
    else if(i == 6){
      if(H_dc_2u1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2u1_rawtdc[0]);
    }
    else if(i == 7){
      if(H_dc_2u2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2u2_rawtdc[0]);
    }
    else if(i == 8){
      if(H_dc_2x1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2x1_rawtdc[0]);
    }
    else if(i == 9){
      if(H_dc_2x2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2x2_rawtdc[0]);
    }
    else if(i == 10){
      if(H_dc_2v1_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2v1_rawtdc[0]);
    }
    else if(i == 11){
      if(H_dc_2v2_nhit[0] == 1) h1hdcTdcT[i]->Fill(H_dc_2v2_rawtdc[0]);
    }
  }
  
  for (Int_t npl = 0; npl < cal_planes; npl++){ // Loop over all calorimeter planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      for (Int_t ipmt = 0; ipmt < 13; ipmt++){ // Loop over each PMT in a particular plane	
	if (npl == 0 && nside == 0) {
	  if (H_cal_1pr_goodPosAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_1pr_goodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 0){
	  if (H_cal_2ta_goodPosAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_2ta_goodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 2 && nside == 0){
	  if (H_cal_3ta_goodPosAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_3ta_goodPosAdcTdcDiffTime[ipmt]);
	}  
	else if (npl == 3 && nside == 0){
	  if (H_cal_4ta_goodPosAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_4ta_goodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 0 && nside == 1){
	  if (H_cal_1pr_goodNegAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_1pr_goodNegAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 1){
	  if (H_cal_2ta_goodNegAdcMult[ipmt] == 1) h1hCalAdcTdcTDiff[npl][nside][ipmt]->Fill(H_cal_2ta_goodNegAdcTdcDiffTime[ipmt]);
	}
      }
    }
  }

  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      for (Int_t ipmt = 0; ipmt < hmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	if (npl == 0 && nside == 0){
	  if (H_hod_1x_GoodPosAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_1x_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 0){
	  if (H_hod_1y_GoodPosAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_1y_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 2 && nside == 0){
	  if (H_hod_2x_GoodPosAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_2x_GoodPosAdcTdcDiffTime[ipmt]);
	}  
	else if (npl == 3 && nside == 0){
	  if (H_hod_2y_GoodPosAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_2y_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 0 && nside == 1){
	  if (H_hod_1x_GoodNegAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_1x_GoodNegAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 1){
	  if (H_hod_1y_GoodNegAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_1y_GoodNegAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 2 && nside == 1){
	  if (H_hod_2x_GoodNegAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_2x_GoodNegAdcTdcDiffTime[ipmt]);
	}  
	else if (npl == 3 && nside == 1){
	  if (H_hod_2y_GoodNegAdcMult[ipmt] == 1) h1hHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(H_hod_2y_GoodNegAdcTdcDiffTime[ipmt]);
	} 	
      }
    }
  }
  
  // Fill our SHMS timing histograms, explicitly select only multiplicity 1 events
  for (Int_t ipmt = 0; ipmt < 4; ipmt++){
    if(P_hgcer_goodAdcMult[ipmt] == 1) h1pHGCAdcTdcTDiff[ipmt]->Fill(P_hgcer_goodAdcTdcDiffTime[ipmt]);
  }
  
  for (Int_t nside = 0; nside < sides; nside++){
    for (Int_t ipmt = 0; ipmt < 7; ipmt++){
      if(nside == 0){
	if(P_aero_goodPosAdcMult[ipmt] == 1) h1pAeroAdcTdcTDiff[nside][ipmt]->Fill(P_aero_goodPosAdcTdcDiffTime[ipmt]);
      }
      else if(nside == 1){
	if(P_aero_goodNegAdcMult[ipmt] == 1) h1pAeroAdcTdcTDiff[nside][ipmt]->Fill(P_aero_goodNegAdcTdcDiffTime[ipmt]);  
      }
    }
  }

  for (Int_t i = 0; i < 12; i++){
    if(i == 0){if(P_dc_1u1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1u1_rawtdc[0]);}
    else if(i == 1){
      if(P_dc_1u2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1u2_rawtdc[0]);
    }
    else if(i == 2){
      if(P_dc_1x1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1x1_rawtdc[0]);
    }
    else if(i == 3){
      if(P_dc_1x2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1x2_rawtdc[0]);
    }
    else if(i == 4){
      if(P_dc_1v1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1v1_rawtdc[0]);
    }
    else if(i == 5){
      if(P_dc_1v2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_1v2_rawtdc[0]);
    }
    else if(i == 6){
      if(P_dc_2u1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2u1_rawtdc[0]);
    }
    else if(i == 7){
      if(P_dc_2u2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2u2_rawtdc[0]);
    }
    else if(i == 8){
      if(P_dc_2x1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2x1_rawtdc[0]);
    }
    else if(i == 9){
      if(P_dc_2x2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2x2_rawtdc[0]);
    }
    else if(i == 10){
      if(P_dc_2v1_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2v1_rawtdc[0]);
    }
    else if(i == 11){
      if(P_dc_2v2_nhit[0] == 1) h1pdcTdcT[i]->Fill(P_dc_2v2_rawtdc[0]);
    }
  }

  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      for (Int_t ipmt = 0; ipmt < pmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	if (npl == 0 && nside == 0){
	  if (P_hod_1x_GoodPosAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_1x_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 0){
	  if (P_hod_1y_GoodPosAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_1y_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 2 && nside == 0){
	  if (P_hod_2x_GoodPosAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_2x_GoodPosAdcTdcDiffTime[ipmt]);
	}  
	else if (npl == 3 && nside == 0){
	  if (P_hod_2y_GoodPosAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_2y_GoodPosAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 0 && nside == 1){
	  if (P_hod_1x_GoodNegAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_1x_GoodNegAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 1 && nside == 1){
	  if (P_hod_1y_GoodNegAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_1y_GoodNegAdcTdcDiffTime[ipmt]);
	}
	else if (npl == 2 && nside == 1){
	  if (P_hod_2x_GoodNegAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_2x_GoodNegAdcTdcDiffTime[ipmt]);
	}  
	else if (npl == 3 && nside == 1){
	  if (P_hod_2y_GoodNegAdcMult[ipmt] == 1) h1pHodoAdcTdcTDiff[npl][nside][ipmt]->Fill(P_hod_2y_GoodNegAdcTdcDiffTime[ipmt]);
	} 	
      }
    }
  }  

  for (Int_t nside = 0; nside < sides; nside++){
    for (Int_t ipmt = 0; ipmt < 14; ipmt++){
      if(nside == 0){
	if(P_cal_pr_goodPosAdcMult[ipmt] == 1) h1pPrShAdcTdcTDiff[nside][ipmt]->Fill(P_cal_pr_goodPosAdcTdcDiffTime[ipmt]);
      }
      else if(nside == 1){
	if(P_cal_pr_goodNegAdcMult[ipmt] == 1) h1pPrShAdcTdcTDiff[nside][ipmt]->Fill(P_cal_pr_goodNegAdcTdcDiffTime[ipmt]);  
      }
    }
  }

  for (Int_t ipmt = 0; ipmt < 224; ipmt++){
    if(P_cal_fly_goodAdcMult[ipmt] == 1) h1pCalAdcTdcTDiff[ipmt]->Fill(P_cal_fly_goodAdcTdcDiffTime[ipmt]);
  }

  return kTRUE;

}

void DetTCuts_Coin::SlaveTerminate()
{
}

void DetTCuts_Coin::Terminate()
{
  cout << "Finished processing" << endl;
  printf("\n");
  TString option = GetOption();

  TFile *Histogram_file = new TFile(Form("TimeWindowHistos_Run%i.root",option.Atoi()),"RECREATE");
  TString outputpdf = Form("TimeWindowPlots_Run%i.pdf", option.Atoi()) ; 

  TDirectory *DHMSCER = Histogram_file->mkdir("HMS Cherenkov Timing"); DHMSCER->cd();
  TCanvas *CHMSCER = new TCanvas("CHMSCER", "HMS Cherenkov timing plots", 300,100,1000,900);
  CHMSCER->Divide(2,1);
  for (Int_t ipmt = 0; ipmt < 2; ipmt++){
    TH1F *HMSCER = dynamic_cast<TH1F *>(TProof::GetOutput(Form("hCER%d_timeDiff", ipmt+1), fOutput));
    HMSCER->Write();
    CHMSCER->cd(ipmt+1); HMSCER->Draw();
  }

  TDirectory *DHMSDC = Histogram_file->mkdir("HMS DC Timing"); DHMSDC->cd();
  TCanvas *CHMSDC = new TCanvas("CHMSDC", "HMS DC timing plots", 300,100,1000,900);
  CHMSDC->Divide(4, 3);
  for (Int_t i = 0; i < 12; i++){
    TH1F *HMSDC = dynamic_cast<TH1F *>(TProof::GetOutput(Form("hDC%s_rawTDC", dc_pl_names[i].c_str()), fOutput));
    HMSDC->Write();
    HMSDC_tMin[i] = (HMSDC->GetMean() - (5*HMSDC->GetStdDev()));
    HMSDC_tMax[i] = (HMSDC->GetMean() + (5*HMSDC->GetStdDev()));
    LHMSDC_tMin[i] = new TLine(HMSDC_tMin[i], 0, HMSDC_tMin[i], HMSDC->GetMaximum());
    LHMSDC_tMax[i] = new TLine(HMSDC_tMax[i], 0, HMSDC_tMax[i], HMSDC->GetMaximum());
    LHMSDC_tMin[i]->SetLineColor(kRed); LHMSDC_tMin[i]->SetLineStyle(7); LHMSDC_tMin[i]->SetLineWidth(1);
    LHMSDC_tMax[i]->SetLineColor(kRed); LHMSDC_tMax[i]->SetLineStyle(7); LHMSDC_tMax[i]->SetLineWidth(1);
    CHMSDC->cd(i+1); HMSDC->Draw(); LHMSDC_tMin[i]->Draw("SAME"); LHMSDC_tMax[i]->Draw("SAME");
  }

  TDirectory *DHMSCAL = Histogram_file->mkdir("HMS Calorimeter Timing"); DHMSCAL->cd();  
  TCanvas *CHMSCAL[4][2];
  for (Int_t npl = 0; npl < cal_planes; npl++){ // Loop over all calorimeter planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      if(npl == 2 && nside == 1) continue; // Skip 3ta/4ta- since they don't exist!
      if(npl == 3 && nside == 1) continue;
      CHMSCAL[npl][nside] = new TCanvas(Form("CHMSCAL%s%s", cal_pl_names[npl].c_str(), nsign[nside].c_str()),  Form("HMS Calorimeter %s%s Timing", cal_pl_names[npl].c_str(), nsign[nside].c_str()), 300,100,1000,900);
      CHMSCAL[npl][nside]->Divide(5, 3);
      for (Int_t ipmt = 0; ipmt < 13; ipmt++){ // Loop over each PMT in a particular plane	
	TH1F *HMSCAL = dynamic_cast<TH1F *>(TProof::GetOutput(Form("hCal%s%d%s_timeDiff", cal_pl_names[npl].c_str(), ipmt+1, nsign[nside].c_str()), fOutput));
	HMSCAL->Write();
	HMSCAL_tMin[npl][nside][ipmt] = (HMSCAL->GetMean() - (5*HMSCAL->GetStdDev()));
	HMSCAL_tMax[npl][nside][ipmt] = (HMSCAL->GetMean() + (5*HMSCAL->GetStdDev()));
	LHMSCAL_tMin[npl][nside][ipmt] = new TLine(HMSCAL_tMin[npl][nside][ipmt], 0, HMSCAL_tMin[npl][nside][ipmt], HMSCAL->GetMaximum());
	LHMSCAL_tMax[npl][nside][ipmt] = new TLine(HMSCAL_tMax[npl][nside][ipmt], 0, HMSCAL_tMax[npl][nside][ipmt], HMSCAL->GetMaximum());
	LHMSCAL_tMin[npl][nside][ipmt]->SetLineColor(kRed); LHMSCAL_tMin[npl][nside][ipmt]->SetLineStyle(7); LHMSCAL_tMin[npl][nside][ipmt]->SetLineWidth(1);
	LHMSCAL_tMax[npl][nside][ipmt]->SetLineColor(kRed); LHMSCAL_tMax[npl][nside][ipmt]->SetLineStyle(7); LHMSCAL_tMax[npl][nside][ipmt]->SetLineWidth(1);
	CHMSCAL[npl][nside]->cd(ipmt+1); HMSCAL->Draw(); LHMSCAL_tMin[npl][nside][ipmt]->Draw("SAME"); LHMSCAL_tMax[npl][nside][ipmt]->Draw("SAME");
      }
    }
  }

  TDirectory *DHMSHODO = Histogram_file->mkdir("HMS Hodoscope Timing"); DHMSHODO->cd();  
  TCanvas *CHMSHODO[4][2];  
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      CHMSHODO[npl][nside] = new TCanvas(Form("CHMSHODO%s%s", hod_pl_names[npl].c_str(), nsign[nside].c_str()),  Form("HMS Hodoscope %s%s Timing", hod_pl_names[npl].c_str(), nsign[nside].c_str()), 300,100,1000,900);
      CHMSHODO[npl][nside]->Divide(4, 4);
      for (Int_t ipmt = 0; ipmt < hmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	TH1F *HMSHODO = dynamic_cast<TH1F *>(TProof::GetOutput(Form("hHodo%s%d%s_timeDiff", hod_pl_names[npl].c_str(),ipmt+1,nsign[nside].c_str() ), fOutput));
	HMSHODO->Write();
	HMSHODO_tMin[npl][nside][ipmt] = (HMSHODO->GetMean() - (5*HMSHODO->GetStdDev()));
	HMSHODO_tMax[npl][nside][ipmt] = (HMSHODO->GetMean() + (5*HMSHODO->GetStdDev()));
	LHMSHODO_tMin[npl][nside][ipmt] = new TLine(HMSHODO_tMin[npl][nside][ipmt], 0, HMSHODO_tMin[npl][nside][ipmt], HMSHODO->GetMaximum());
	LHMSHODO_tMax[npl][nside][ipmt] = new TLine(HMSHODO_tMax[npl][nside][ipmt], 0, HMSHODO_tMax[npl][nside][ipmt], HMSHODO->GetMaximum());
	LHMSHODO_tMin[npl][nside][ipmt]->SetLineColor(kRed); LHMSHODO_tMin[npl][nside][ipmt]->SetLineStyle(7); LHMSHODO_tMin[npl][nside][ipmt]->SetLineWidth(1);
	LHMSHODO_tMax[npl][nside][ipmt]->SetLineColor(kRed); LHMSHODO_tMax[npl][nside][ipmt]->SetLineStyle(7); LHMSHODO_tMax[npl][nside][ipmt]->SetLineWidth(1);
	CHMSHODO[npl][nside]->cd(ipmt+1); HMSHODO->Draw(); LHMSHODO_tMin[npl][nside][ipmt]->Draw("SAME"); LHMSHODO_tMax[npl][nside][ipmt]->Draw("SAME");
      }
    }
  }

  TDirectory *DSHMSHGC = Histogram_file->mkdir("SHMS HGC Timing"); DSHMSHGC->cd();  
  TCanvas *CSHMSHGC = new TCanvas("CSHMSHGC", "SHMS HGC timing plots", 300,100,1000,900);
  CSHMSHGC->Divide(2,2);
  for (Int_t ipmt = 0; ipmt < 4; ipmt++){
    TH1F *SHMSHGC = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pHGCER%d_timeDiff", ipmt+1), fOutput));
    SHMSHGC->Write();
    CSHMSHGC->cd(ipmt+1); SHMSHGC->Draw();
  }

  TDirectory *DSHMSAERO = Histogram_file->mkdir("SHMS Aerogel Cherenkov Timing"); DSHMSAERO->cd();  
  TCanvas *CSHMSAERO[2];
  for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
    CSHMSAERO[nside] = new TCanvas(Form("CSHMSAERO%s", nsign[nside].c_str()),  Form("SHMS Aerogel  %sPMT Timing", nsign[nside].c_str()), 300,100,1000,900);
    CSHMSAERO[nside]->Divide(2, 4);
    for (Int_t ipmt = 0; ipmt < 7; ipmt++){ // Loop over PMTs
      TH1F *SHMSAERO = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pAero%d%s_timeDiff", ipmt+1, nsign[nside].c_str()), fOutput));
      SHMSAERO->Write();
      SHMSAERO_tMin[nside][ipmt] = (SHMSAERO->GetMean() - (5*SHMSAERO->GetStdDev()));
      SHMSAERO_tMax[nside][ipmt] = (SHMSAERO->GetMean() + (5*SHMSAERO->GetStdDev()));
      if(SHMSAERO_tMin[nside][ipmt] < 0) SHMSAERO_tMin[nside][ipmt] = 0;
      LSHMSAERO_tMin[nside][ipmt] = new TLine(SHMSAERO_tMin[nside][ipmt], 0, SHMSAERO_tMin[nside][ipmt], SHMSAERO->GetMaximum());
      LSHMSAERO_tMax[nside][ipmt] = new TLine(SHMSAERO_tMax[nside][ipmt], 0, SHMSAERO_tMax[nside][ipmt], SHMSAERO->GetMaximum());
      LSHMSAERO_tMin[nside][ipmt]->SetLineColor(kRed); LSHMSAERO_tMin[nside][ipmt]->SetLineStyle(7); LSHMSAERO_tMin[nside][ipmt]->SetLineWidth(1);
      LSHMSAERO_tMax[nside][ipmt]->SetLineColor(kRed); LSHMSAERO_tMax[nside][ipmt]->SetLineStyle(7); LSHMSAERO_tMax[nside][ipmt]->SetLineWidth(1);
      CSHMSAERO[nside]->cd(ipmt+1); SHMSAERO->Draw(); LSHMSAERO_tMin[nside][ipmt]->Draw("SAME"); LSHMSAERO_tMax[nside][ipmt]->Draw("SAME");
    }
  }
  
  TDirectory *DSHMSDC = Histogram_file->mkdir("SHMS DC Timing"); DSHMSDC->cd();  
  TCanvas *CSHMSDC = new TCanvas("CSHMSDC", "SHMS DC timing plots", 300,100,1000,900);
  CSHMSDC->Divide(4, 3);
  for (Int_t i = 0; i < 12; i++){
    TH1F *SHMSDC = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pDC%s_rawTDC", dc_pl_names[i].c_str()), fOutput));
    SHMSDC->Write();
    SHMSDC_tMin[i] = (SHMSDC->GetMean() - (5*SHMSDC->GetStdDev()));
    SHMSDC_tMax[i] = (SHMSDC->GetMean() + (5*SHMSDC->GetStdDev()));
    LSHMSDC_tMin[i] = new TLine(SHMSDC_tMin[i], 0, SHMSDC_tMin[i], SHMSDC->GetMaximum());
    LSHMSDC_tMax[i] = new TLine(SHMSDC_tMax[i], 0, SHMSDC_tMax[i], SHMSDC->GetMaximum());
    LSHMSDC_tMin[i]->SetLineColor(kRed); LSHMSDC_tMin[i]->SetLineStyle(7); LSHMSDC_tMin[i]->SetLineWidth(1);
    LSHMSDC_tMax[i]->SetLineColor(kRed); LSHMSDC_tMax[i]->SetLineStyle(7); LSHMSDC_tMax[i]->SetLineWidth(1);
    CSHMSDC->cd(i+1); SHMSDC->Draw(); LSHMSDC_tMin[i]->Draw("SAME"); LSHMSDC_tMax[i]->Draw("SAME");
  }

  TDirectory *DSHMSHODO = Histogram_file->mkdir("SHMS Hodoscope Timing"); DSHMSHODO->cd();  
  TCanvas *CSHMSHODO[4][2];  
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      CSHMSHODO[npl][nside] = new TCanvas(Form("CSHMSHODO%s%s", hod_pl_names[npl].c_str(), nsign[nside].c_str()),  Form("SHMS Hodoscope %s%s Timing", hod_pl_names[npl].c_str(), nsign[nside].c_str()), 300,100,1000,900);
      if (npl != 3) CSHMSHODO[npl][nside]->Divide(5, 3);
      else if (npl == 3) CSHMSHODO[npl][nside]->Divide(7, 3);
      for (Int_t ipmt = 0; ipmt < pmaxPMT[npl]; ipmt++){ // Loop over each PMT in a particular plane	
	TH1F *SHMSHODO = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pHodo%s%d%s_timeDiff", hod_pl_names[npl].c_str(),ipmt+1,nsign[nside].c_str() ), fOutput));
	SHMSHODO->Write();
	CSHMSHODO[npl][nside]->cd(ipmt+1); SHMSHODO->Draw();
      }
    }
  }

  TDirectory *DSHMSPRSH = Histogram_file->mkdir("SHMS Pre-Shower Timing"); DSHMSPRSH->cd();  
  TCanvas *CSHMSPRSH[2];
  for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
    CSHMSPRSH[nside] = new TCanvas(Form("CSHMSPRSH%s", nsign[nside].c_str()),  Form("SHMS Pre-Shower  %sPMT Timing", nsign[nside].c_str()), 300,100,1000,900);
    CSHMSPRSH[nside]->Divide(5, 3);    
    for (Int_t ipmt = 0; ipmt < 14; ipmt++){ // Loop over PMTs
      TH1F *SHMSPRSH = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pPrSh%d%s_timeDiff", ipmt+1, nsign[nside].c_str()), fOutput));
      SHMSPRSH->Write();
      CSHMSPRSH[nside]->cd(ipmt+1); SHMSPRSH->Draw();
    }
  }
  
  TDirectory *DSHMSCAL = Histogram_file->mkdir("SHMS Calorimeter Timing"); DSHMSCAL->cd();  
  TCanvas *CSHMSCAL[14]; // 16 histograms per canvas
  for(Int_t row = 0; row < 14; row++){
    CSHMSCAL[row] = new TCanvas(Form("CSHMSCAL%d", row+1),  Form("SHMS Pre-Shower Row %d", row+1), 300,100,1000,900);
    CSHMSCAL[row]->Divide(4, 4);     
    for(Int_t ipmt = 0; ipmt < 16; ipmt++){
      TH1F *SHMSCAL = dynamic_cast<TH1F *>(TProof::GetOutput(Form("pCalPMT%d", (row*16)+ipmt+1), fOutput)); 
      SHMSCAL->Write();
      SHMSCAL_tMin[row][ipmt] = (SHMSCAL->GetMean() - (5*SHMSCAL->GetStdDev()));
      SHMSCAL_tMax[row][ipmt] = (SHMSCAL->GetMean() + (5*SHMSCAL->GetStdDev()));
      LSHMSCAL_tMin[row][ipmt] = new TLine(SHMSCAL_tMin[row][ipmt], 0, SHMSCAL_tMin[row][ipmt], SHMSCAL->GetMaximum());
      LSHMSCAL_tMax[row][ipmt] = new TLine(SHMSCAL_tMax[row][ipmt], 0, SHMSCAL_tMax[row][ipmt], SHMSCAL->GetMaximum());
      LSHMSCAL_tMin[row][ipmt]->SetLineColor(kRed); LSHMSCAL_tMin[row][ipmt]->SetLineStyle(7); LSHMSCAL_tMin[row][ipmt]->SetLineWidth(1);
      LSHMSCAL_tMax[row][ipmt]->SetLineColor(kRed); LSHMSCAL_tMax[row][ipmt]->SetLineStyle(7); LSHMSCAL_tMax[row][ipmt]->SetLineWidth(1);
      CSHMSCAL[row]->cd(ipmt+1); SHMSCAL->Draw(); SHMSCAL->Draw(); LSHMSCAL_tMin[row][ipmt]->Draw("SAME"); LSHMSCAL_tMax[row][ipmt]->Draw("SAME");
    }
  }

  CHMSCER->Print(outputpdf+"[");
  CHMSCER->Print(outputpdf);
  CHMSDC->Print(outputpdf);
  for (Int_t npl = 0; npl < cal_planes; npl++){ // Loop over all calorimeter planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      if(npl == 2 && nside == 1) continue; // Skip 3ta/4ta- since they don't exist!
      if(npl == 3 && nside == 1) continue;
      CHMSCAL[npl][nside]->Print(outputpdf);
    }
  }
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      CHMSHODO[npl][nside]->Print(outputpdf);
    }
  }
  CSHMSHGC->Print(outputpdf);
  CSHMSAERO[0]->Print(outputpdf);
  CSHMSAERO[1]->Print(outputpdf);
  CSHMSDC->Print(outputpdf);
  for (Int_t npl = 0; npl < hod_planes; npl++){ // Loop over all hodoscope planes
    for (Int_t nside = 0; nside < sides; nside++){ //Loop over each side
      CSHMSHODO[npl][nside]->Print(outputpdf);
    }
  }
  CSHMSPRSH[0]->Print(outputpdf);
  CSHMSPRSH[1]->Print(outputpdf);
  for(Int_t row = 0; row < 14; row++){
    CSHMSCAL[row]->Print(outputpdf);
  }
  CHMSCER->Print(outputpdf+"]");
  
  Histogram_file->Close();

  // Output time windows to some parameter files
  // This code is heavily based on code written by Carlos Yero for a similar analysis script so credit for it goes to him here!

  string n_side[2] = {"Pos", "Neg"};
  string n_side_cal[2] = {"pos", "neg"};
  string n_lim[2] = {"Min", "Max"};
  
  ofstream out_hhodo;
  ofstream out_phodo;
  ofstream out_hcal;
  ofstream out_pprsh;  
  ofstream out_pcal;  
  ofstream out_hdc;   
  ofstream out_pdc;   
  ofstream out_hcer; 
  ofstream out_phgcer;
  ofstream out_paero; 

  //HMS Hodo
  out_hhodo.open(Form("hhodo_tWin_%d.param", option.Atoi()));
  out_hhodo << "; HMS Hodoscope Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_hhodo << " " << endl;
  out_hhodo << " " << endl;
  out_hhodo << " " << endl;
  //SHMS Hodo
  out_phodo.open(Form("phodo_tWin_%d.param", option.Atoi()));
  out_phodo << "; SHMS Hodoscope Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_phodo << " " << endl;
  out_phodo << " " << endl;
  out_phodo << " " << endl;
  //HMS Cal
  out_hcal.open(Form("hcal_tWin_%d.param", option.Atoi()));
  out_hcal << "; HMS Calorimeter Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_hcal << " " << endl;
  out_hcal << " " << endl;
  out_hcal << " " << endl;
  //SHMS PreSh
  out_pprsh.open(Form("pprsh_tWin_%d.param", option.Atoi()));
  out_pprsh << "; SHMS Pre-Shower Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_pprsh << " " << endl;
  out_pprsh << " " << endl;
  out_pprsh << " " << endl;
  //SHMS Fly's Eye Cal
  out_pcal.open(Form("pcal_tWin_%d.param", option.Atoi()));
  out_pcal << "; SHMS Fly's Eye Calorimeter  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_pcal << " " << endl;
  out_pcal << " " << endl;
  out_pcal << " " << endl;
  //HMS DC
  out_hdc.open(Form("hdc_tWin_%d.param", option.Atoi()));
  out_hdc << "; HMS DC  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_hdc << " " << endl;
  out_hdc << " " << endl;
  out_hdc << " " << endl;
  //SHMS DC
  out_pdc.open(Form("pdc_tWin_%d.param", option.Atoi()));
  out_pdc << "; SHMS DC  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_pdc << " " << endl;
  out_pdc << " " << endl;
  out_pdc << " " << endl;
  //HMS Cer
  out_hcer.open(Form("hcer_tWin_%d.param", option.Atoi()));
  out_hcer << "; HMS Cer  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_hcer << " " << endl;
  out_hcer << " " << endl;
  out_hcer << " " << endl;
  //SHMS HGCER
  out_phgcer.open(Form("phgcer_tWin_%d.param", option.Atoi()));
  out_phgcer << "; SHMS Heavy Gas Cer  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_phgcer << " " << endl;
  out_phgcer << " " << endl;
  out_phgcer << " " << endl;
  //SHMS AERO
  out_paero.open(Form("paero_tWin_%d.param", option.Atoi()));
  out_paero << "; SHMS Aerogel Cer  Parameter File Containing TimeWindow Min/Max Cuts " << endl;
  out_paero << " " << endl;
  out_paero << " " << endl;
  out_paero << " " << endl;

  for(Int_t iside = 0; iside<2; iside++){
    //Loop over Min/Max Window Limits
    for (Int_t lim = 0; lim<2; lim++){ 
      //Minimum Time Window
      if(lim==0){
	//HMS Hodo
	out_hhodo << "" << endl;
	out_hhodo << "; " << setw(32) << "1x " << setw(19) << "1y " << setw(16) << "2x " << setw(16) << "2y " << endl;
	out_hhodo << Form("hhodo_%sAdcTimeWindow%s = ", n_side[iside].c_str(), n_lim[lim].c_str());
	//SHMS Hodo
	out_phodo << "" << endl;
	out_phodo << "; " << setw(32) << "1x " << setw(19) << "1y " << setw(16) << "2x " << setw(16) << "2y " << endl;
	out_phodo << Form("phodo_%sAdcTimeWindow%s = ", n_side[iside].c_str(), n_lim[lim].c_str());
	//HMS Calorimeter
	out_hcal << "" << endl;
	out_hcal << Form("hcal_%s_AdcTimeWindow%s = ", n_side_cal[iside].c_str(), n_lim[lim].c_str());
	//SHMS PreSHower
	out_pprsh << "" << endl;
	out_pprsh << Form("pcal_%s_AdcTimeWindow%s = ", n_side_cal[iside].c_str(), n_lim[lim].c_str());   
	//SHMS_Aero
	out_paero << "" << endl;
	out_paero << Form("paero_adc%sTimeWindow%s = ", n_side[iside].c_str(),n_lim[lim].c_str());
	if(iside==0){
	  //SHMS Fly's Eye
	  out_pcal << "" << endl;
	  out_pcal << Form("pcal_arr_AdcTimeWindow%s = ", n_lim[lim].c_str());
	  //HMS DC
	  out_hdc << "" << endl;
	  out_hdc << "hdc_tdc_min_win = ";
	  //SHMS DC
	  out_pdc << "" << endl;
	  out_pdc << "pdc_tdc_min_win = ";
	  //HMS Cer
	  out_hcer << "" << endl;
	  out_hcer << "hcer_adcTimeWindowMin = ";
	  //SHMS HGCER
	  out_phgcer << "" << endl;
	  out_phgcer << "phgcer_adcTimeWindowMin = ";
	}
      }
      //Maximum Time Window
      if(lim==1){
	//HMS Hodo
	out_hhodo << "" << endl;
	out_hhodo << "; " << setw(32) << "1x " << setw(19) << "1y " << setw(16) << "2x " << setw(16) << "2y " << endl;
	out_hhodo << Form("hhodo_%sAdcTimeWindow%s = ", n_side[iside].c_str(), n_lim[lim].c_str());
	//SHMS Hodo
	out_phodo << "" << endl;
	out_phodo << "; " << setw(32) << "1x " << setw(19) << "1y " << setw(16) << "2x " << setw(16) << "2y " << endl;
	out_phodo << Form("phodo_%sAdcTimeWindow%s = ", n_side[iside].c_str(), n_lim[lim].c_str());
	//HMS Calorimeter
	out_hcal << "" << endl;
	out_hcal << Form("hcal_%s_AdcTimeWindow%s = ", n_side_cal[iside].c_str(), n_lim[lim].c_str());	        
	//SHMS PreSHower
	out_pprsh << "" << endl;
	out_pprsh << Form("pcal_%s_AdcTimeWindow%s = ", n_side_cal[iside].c_str(), n_lim[lim].c_str());
	//SHMS_Aero
	out_paero << "" << endl;
	out_paero << Form("paero_adc%sTimeWindow%s = ", n_side[iside].c_str(),n_lim[lim].c_str());
	if(iside==0){
	  //SHMS Fly's Eye
	  out_pcal << "" << endl;
	  out_pcal << Form("pcal_arr_AdcTimeWindow%s = ", n_lim[lim].c_str());
	  //HMS DC
	  out_hdc << "" << endl;
	  out_hdc << "hdc_tdc_max_win = ";
	  //SHMS DC
	  out_pdc << "" << endl;
	  out_pdc << "pdc_tdc_max_win = ";
	  //HMS Cer
	  out_hcer << "" << endl;
	  out_hcer << "hcer_adcTimeWindowMax = ";
	  //SHMS HGCER
	  out_phgcer << "" << endl;
	  out_phgcer << "phgcer_adcTimeWindowMax = ";
	}
      }

      for(int ipmt = 0; ipmt<21; ipmt++){     
	//--------Write out HMS Hodo Param---------
	if(ipmt<16){
	  if(ipmt==0){   
	    if (lim==0){
	      out_hhodo << setprecision(2) << HMSHODO_tMin[0][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[1][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[2][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[3][iside][ipmt] << fixed << endl; 
	    }
	    if(lim==1){
	      out_hhodo << setprecision(2) << HMSHODO_tMax[0][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[1][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[2][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[3][iside][ipmt] << fixed << endl; 
	    }
	  }
	  else{
	    if(lim==0){
	      out_hhodo << setw(32) << setprecision(2) << HMSHODO_tMin[0][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[1][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[2][iside][ipmt] << ", " << setw(15) << HMSHODO_tMin[3][iside][ipmt] << fixed << endl; 
	    }
	    if(lim==1){
	      out_hhodo << setw(32) << setprecision(2) << HMSHODO_tMax[0][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[1][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[2][iside][ipmt] << ", " << setw(15) << HMSHODO_tMax[3][iside][ipmt] << fixed << endl; 
	    }   
	  }
	}//end HMS Hodo PMT Loop          
	//------Write out SHMS Hodo Param-------
	if(ipmt==0){	
	  if (lim==0){
	    out_phodo << setprecision(2) << SHMSHODO_tMin[0][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[1][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[2][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[3][iside][ipmt] << fixed << endl; 
	  }
	  if(lim==1){
	    out_phodo << setprecision(2) << SHMSHODO_tMax[0][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[1][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[2][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[3][iside][ipmt] << fixed << endl; 
	  }
	}   
	else{
	  if(lim==0){
	    out_phodo << setw(32) << setprecision(2) << SHMSHODO_tMin[0][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[1][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[2][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMin[3][iside][ipmt] << fixed << endl; 
	  }
	  if(lim==1){
	    out_phodo << setw(32) << setprecision(2) << SHMSHODO_tMax[0][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[1][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[2][iside][ipmt] << ", " << setw(15) << SHMSHODO_tMax[3][iside][ipmt] << fixed << endl; 
	  }	
	}
      } //end loop over pmts

      //-----Write out HMS Calorimeter-------
      for(Int_t layer = 0; layer < 4; layer++){	            
	if(layer < 2 ){
	  if(lim==0){
	    out_hcal << setprecision(2) << HMSCAL_tMin[layer][iside][0]<<","
		     << HMSCAL_tMin[layer][iside][1]<<","
		     << HMSCAL_tMin[layer][iside][2]<<","
		     << HMSCAL_tMin[layer][iside][3]<<","
		     << HMSCAL_tMin[layer][iside][4]<<","
		     << HMSCAL_tMin[layer][iside][5]<<","
		     << HMSCAL_tMin[layer][iside][6]<<","
		     << HMSCAL_tMin[layer][iside][7]<<","
		     << HMSCAL_tMin[layer][iside][8]<<","
		     << HMSCAL_tMin[layer][iside][9]<<","
		     << HMSCAL_tMin[layer][iside][10]<<","
		     << HMSCAL_tMin[layer][iside][11]<<","
		     << HMSCAL_tMin[layer][iside][12]<< fixed << endl;
	  } // end Min Limit
	  if(lim==1){
	    out_hcal << setprecision(2) << HMSCAL_tMax[layer][iside][0]<<","
		     << HMSCAL_tMax[layer][iside][1]<<","
		     << HMSCAL_tMax[layer][iside][2]<<","
		     << HMSCAL_tMax[layer][iside][3]<<","
		     << HMSCAL_tMax[layer][iside][4]<<","
		     << HMSCAL_tMax[layer][iside][5]<<","
		     << HMSCAL_tMax[layer][iside][6]<<","
		     << HMSCAL_tMax[layer][iside][7]<<","
		     << HMSCAL_tMax[layer][iside][8]<<","
		     << HMSCAL_tMax[layer][iside][9]<<","
		     << HMSCAL_tMax[layer][iside][10]<<","
		     << HMSCAL_tMax[layer][iside][11]<<","
		     << HMSCAL_tMax[layer][iside][12]<< fixed << endl;
	  } //end Max Limit
	} //end layer<2 requirement
	else if (layer > 1){
	  if(iside == 0){ // Only do +ve side
	    if(lim==0){
	      out_hcal << setprecision(2) << HMSCAL_tMin[layer][iside][0]<<","
		       << HMSCAL_tMin[layer][iside][1]<<","
		       << HMSCAL_tMin[layer][iside][2]<<","
		       << HMSCAL_tMin[layer][iside][3]<<","
		       << HMSCAL_tMin[layer][iside][4]<<","
		       << HMSCAL_tMin[layer][iside][5]<<","
		       << HMSCAL_tMin[layer][iside][6]<<","
		       << HMSCAL_tMin[layer][iside][7]<<","
		       << HMSCAL_tMin[layer][iside][8]<<","
		       << HMSCAL_tMin[layer][iside][9]<<","
		       << HMSCAL_tMin[layer][iside][10]<<","
		       << HMSCAL_tMin[layer][iside][11]<<","
		       << HMSCAL_tMin[layer][iside][12]<< fixed << endl;
	    } // end Min Limit
	    if(lim==1){
	      out_hcal << setprecision(2) << HMSCAL_tMax[layer][iside][0]<<","
		       << HMSCAL_tMax[layer][iside][1]<<","
		       << HMSCAL_tMax[layer][iside][2]<<","
		       << HMSCAL_tMax[layer][iside][3]<<","
		       << HMSCAL_tMax[layer][iside][4]<<","
		       << HMSCAL_tMax[layer][iside][5]<<","
		       << HMSCAL_tMax[layer][iside][6]<<","
		       << HMSCAL_tMax[layer][iside][7]<<","
		       << HMSCAL_tMax[layer][iside][8]<<","
		       << HMSCAL_tMax[layer][iside][9]<<","
		       << HMSCAL_tMax[layer][iside][10]<<","
		       << HMSCAL_tMax[layer][iside][11]<<","
		       << HMSCAL_tMax[layer][iside][12]<< fixed << endl;
	    } //end Max Limit
	  }
	  else if (iside == 1){
	    if(lim==0){
	      out_hcal << setprecision(2) << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 << fixed << endl;
	    } // end Min Limit
	    if(lim==1){
	      out_hcal << setprecision(2) << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 <<","
		       << 0.0 << fixed << endl;
	    } //end Max Limit	      
	  } // End loop over side == 1
	} // End loop over last two layers
      } // End loop over layers

	//------Write SHMS PreShower Param-------
	//Lower Limit Time Window Cut
	// if(lim==0){
	//   out_pprsh << setprecision(2) << SHMSPRSH_tMin[iside][0] << ", " << SHMSPRSH_tMin[iside][1] << ", " 
	// 		<<  SHMSPRSH_tMin[iside][2] << ", "  <<  SHMSPRSH_tMin[iside][3]  << ", " 
	// 		<<  SHMSPRSH_tMin[iside][4] << ", "  <<  SHMSPRSH_tMin[iside][5]  << ", " 
	// 		<<  SHMSPRSH_tMin[iside][6] << ", "  <<  SHMSPRSH_tMin[iside][7]  << ", "
	// 		<<  SHMSPRSH_tMin[iside][8] << ", "  <<  SHMSPRSH_tMin[iside][9]  << ", " 
	// 		<<  SHMSPRSH_tMin[iside][10] << ", " <<  SHMSPRSH_tMin[iside][11] << ", " 
	// 		<<  SHMSPRSH_tMin[iside][12] << ", " <<  SHMSPRSH_tMin[iside][13] << fixed << endl;
	// }
	// //Upper Limit Time Window Cut
	// if(lim==1){
	//   out_pprsh << setprecision(2) << SHMSPRSH_tMax[iside][0] << ", " << SHMSPRSH_tMax[iside][1] << ", " 
	// 		<<  SHMSPRSH_tMax[iside][2] << ", "  <<  SHMSPRSH_tMax[iside][3]  << ", " 
	// 		<<  SHMSPRSH_tMax[iside][4] << ", "  <<  SHMSPRSH_tMax[iside][5]  << ", " 
	// 		<<  SHMSPRSH_tMax[iside][6] << ", "  <<  SHMSPRSH_tMax[iside][7]  << ", "
	// 		<<  SHMSPRSH_tMax[iside][8] << ", "  <<  SHMSPRSH_tMax[iside][9]  << ", " 
	// 		<<  SHMSPRSH_tMax[iside][10] << ", " <<  SHMSPRSH_tMax[iside][11] << ", " 
	// 		<<  SHMSPRSH_tMax[iside][12] << ", " <<  SHMSPRSH_tMax[iside][13] << fixed << endl;
	// }

	//------Write SHMS Aerogel Param-------
      for(Int_t ipmt = 0; ipmt < 7; ipmt++){
	if(lim==0){
	  out_paero << setw(2) << setprecision(2) << SHMSAERO_tMin[iside][ipmt] << ( (ipmt+1) == 7 ? "\n" : ", ") << fixed;
	}
	if(lim==1){
	  out_paero << setw(2) << setprecision(2) << SHMSAERO_tMax[iside][ipmt] << ( (ipmt+1) == 7 ? "\n" : ", ") << fixed;
	}
      }
	  
      if(iside==0){
	//Loop over DC planes
	for(Int_t i = 0; i < 12; i++){
	  //Lower Limit Time Window Cut
	  if(lim==0){
	    out_hdc << setw(2) << setprecision(2) << HMSDC_tMin[i] << ", " << fixed;
	    out_pdc << setw(2) << setprecision(2) << SHMSDC_tMin[i] << ", " << fixed;
	  }
	  //Upper Limit Time Window Cut
	  if(lim==1){
	    out_hdc << setw(2) << setprecision(2) << HMSDC_tMax[i] << ", " << fixed;
	    out_pdc << setw(2) << setprecision(2) << SHMSDC_tMax[i] << ", " << fixed;
	  }
	} //End loop over DC Planes
		
	  //---------Write SHMS Fly's Eye Calorimeter Param-------------
	for(Int_t row = 0; row < 14; row++){
	  for(Int_t ipmt = 0; ipmt < 16; ipmt++){  
	    //Lower Limit Time Window Cut
	    if(lim==0){
	      out_pcal << setw(2) << setprecision(2) << SHMSCAL_tMin[row][ipmt] << ( (ipmt+1) == 16 ? "\n" : ", ") << fixed;
	    }
	    //Upper Limit Time Window Cut
	    if(lim==1){
	      out_pcal << setw(2) << setprecision(2) << SHMSCAL_tMax[row][ipmt] << ( (ipmt+1) == 16 ? "\n" : ", ") << fixed; 
	    }
	  }
	} //End Fly's Eye Cal PMT Loop

	  //---------Write HMS/SHMS CER Param-------------  
	  //Loop over PMTs
	for (int ipmt = 0; ipmt<4; ipmt++){
	  //Lower Limit Time Window Cut
	  if(lim==0){
	    //HMS Cer
	    if(ipmt<2){
	      //out_hcer << setprecision(2) << HMSCER_tMin[ipmt] << ", " << fixed;
	    }
	    //SHMS HGCER
	    //out_phgcer << setprecision(2) << SHMSHGC_tMin[ipmt] << ", " << fixed;
	  }
	 
	  //Upper Limit Time Window Cut
	  if(lim==1){
	    //HMS Cer
	    if(ipmt<2){
	      //out_hcer << setprecision(2) << HMSCER_tMax[ipmt] << ", " << fixed;
	    }
	    //SHMS HGCER
	    //out_phgcer << setprecision(2) << SHMSHGC_tMax[ipmt] << ", " << fixed;
	  }
	}
      } // End loop over min/max limits
    } // End loop over sides
  }
}

